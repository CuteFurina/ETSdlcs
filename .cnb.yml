# CNB构建配置文件
# 功能：自动构建并发布包含完整Git LFS文件的源码包

main:
  # 触发规则配置
  # 1. Tag触发 - 用于正式版本发布
  tags:
    - name: Release Build with Git LFS
      # 明确指定tag匹配模式，确保任何tag创建都能触发
      pattern: "*"
      # 确保构建在列表中可见
      visible: true
      # 设置构建描述，增强可识别性
      description: "由Tag创建触发的源码包构建，包含完整Git LFS文件"
  
  # 2. Push触发 - 增加push触发以提高构建可见性和可靠性
  push:
    - name: Push Trigger Build
      branches:
        - "main"
        - "master"
        - "/^release\/.*/"  # 匹配release/开头的分支
      visible: true
      description: "由代码推送触发的测试构建，用于验证配置"
      # 指定Runner配置
      runner:
        tags: cnb:arch:amd64
        cpus: 4
        memory: 8GiB  # 显式指定内存以确保足够资源处理LFS文件
      # 指定Docker镜像，使用包含git和git-lfs的环境
      docker:
        image: ubuntu:22.04  # 使用具体版本号的镜像以保证一致性
        # 移除不允许的卷挂载路径
      # 流水线阶段
      stages:
        # 准备环境阶段
        - name: Prepare Environment
          script: |
            # 显示构建上下文信息，帮助调试和跟踪
            echo "=== 构建环境信息 ==="
            echo "当前时间: $(date)"
            echo "当前用户: $(whoami)"
            echo "工作目录: $(pwd)"
            echo "CNB构建ID: ${CNB_BUILD_ID:-未设置}"
            echo "触发事件: ${CNB_EVENT_TYPE:-未设置}"
            echo "触发分支/标签: ${CNB_REF_NAME:-未设置}"
            
            # 安装必要的依赖
            apt-get update
            apt-get install -y --no-install-recommends git git-lfs zip curl
            # 初始化git-lfs
            git lfs install
            # 配置git以处理大文件
            git config --global http.postBuffer 1048576000
            
            # 显示CNB环境变量，便于调试
            echo "=== CNB环境变量 ==="
            env | grep -i "CNB_" || echo "未找到CNB相关环境变量"
            
            # 显示Git配置信息
            echo "=== Git配置 ==="
            git config --list
            echo "=== Git远程仓库 ==="
            git remote -v
        
        # 拉取完整代码阶段（包括LFS文件）
        - name: Fetch Complete Code
          script: |
            # 确认git-lfs已正确配置
            echo "Git LFS version:"
            git lfs --version
            
            # 配置Git LFS的缓存和超时设置
            git config --global lfs.fetchrecentrefsdays 7
            git config --global lfs.fetchrecentcommitsdays 7
            git config --global lfs.fetchrecentalways true
            
            # 拉取所有LFS文件，增加超时设置
            echo "开始拉取LFS文件..."
            GIT_HTTP_LOW_SPEED_LIMIT=1000 GIT_HTTP_LOW_SPEED_TIME=600 git lfs fetch --all || echo "LFS fetch可能有错误，但继续执行"
            
            # 检出所有LFS文件到工作目录
            echo "开始检出LFS文件..."
            git lfs checkout
            
            # 验证LFS文件是否成功检出
            echo "LFS文件列表："
            git lfs ls-files
            echo "LFS文件数量："
            git lfs ls-files | wc -l
            
            # 验证部分LFS文件是否已正确检出（不是指针文件）
            echo "验证LFS文件内容..."
            if [ -n "$(git lfs ls-files)" ]; then
              FIRST_LFS_FILE=$(git lfs ls-files | head -n 1 | awk '{print $3}')
              if [ -f "$FIRST_LFS_FILE" ]; then
                echo "第一个LFS文件 $FIRST_LFS_FILE 大小："
                ls -lh "$FIRST_LFS_FILE"
                # 检查是否为指针文件
                if ! head -n 1 "$FIRST_LFS_FILE" | grep -q "version https://git-lfs.github.com/spec/"; then
                  echo "✓ LFS文件已正确检出（不是指针文件）"
                else
                  echo "✗ LFS文件仍然是指针文件，检出可能失败"
                fi
              fi
            fi
        
        # 确保LFS文件正确检出的额外步骤
        - name: Ensure LFS Files Are Checked Out
          script: |
            # 再次检查并确保所有LFS文件都已正确检出
            echo "再次确保LFS文件正确检出..."
            # 对每个LFS文件单独执行checkout，确保不会遗漏
            git lfs ls-files | awk '{print $3}' | xargs -I {} git lfs checkout {}
            
            # 创建一个临时目录来验证LFS文件
            mkdir -p /tmp/lfs-verify
            
            # 复制一些LFS文件到临时目录进行验证
            if [ -n "$(git lfs ls-files)" ]; then
              git lfs ls-files | awk '{print $3}' | head -n 5 | xargs -I {} cp {} /tmp/lfs-verify/ 2>/dev/null || echo "复制部分LFS文件失败，但继续执行"
              echo "临时目录中的LFS文件："
              ls -lh /tmp/lfs-verify/
            fi
        
        # 创建源码包阶段
        - name: Create Source Package
          script: |
            # 获取当前tag名称作为版本号
            VERSION=$(git describe --tags --abbrev=0 || echo "1.0.0")
            echo "当前版本: ${VERSION}"
            echo "当前工作目录内容："
            ls -la
            
            # 创建源码包，包含所有文件（包括LFS文件）
            echo "开始创建源码包..."
            # 使用更高的压缩级别，并显示详细进度
            zip -rv9 "source-package-${VERSION}.zip" . -x "*.git*" "*.zip" "*.log" "tmp/*" "/tmp/*"
            
            # 验证源码包
            echo "源码包信息："
            ls -lh "source-package-${VERSION}.zip" || echo "源码包创建失败"
            
            # 显示包内文件数量，用于验证完整性
            if [ -f "source-package-${VERSION}.zip" ]; then
              echo "包内文件数量："
              unzip -l "source-package-${VERSION}.zip" | wc -l
              
              # 检查包中是否包含LFS文件
              echo "包中的LFS文件："
              LFS_FILES=$(git lfs ls-files | awk '{print $3}')
              for file in $LFS_FILES; do
                if unzip -l "source-package-${VERSION}.zip" | grep -q "$file"; then
                  echo "✓ $file 已包含在源码包中"
                else
                  echo "✗ $file 未包含在源码包中"
                fi
              done
            fi
        
        # 发布Release阶段
        - name: Publish Release
          script: |
            # 显示详细的发布阶段信息，增强可见性
            echo "=== 发布阶段开始 ==="
            echo "当前时间: $(date)"
            
            # 获取当前tag名称，如果失败则使用默认值
            VERSION=$(git describe --tags --abbrev=0 || echo "1.0.0")
            echo "准备发布版本: ${VERSION}"
            
            # 显示完整的Git信息，帮助调试
            echo "=== Git详情 ==="
            git branch -a
            git tag -l
            git log -n 5 --pretty=format:"%h - %an, %ar : %s"
            
            # 验证源码包是否存在且不为空
            if [ -f "source-package-${VERSION}.zip" ] && [ -s "source-package-${VERSION}.zip" ]; then
              echo "源码包验证成功，大小：$(du -h source-package-${VERSION}.zip | cut -f1)"
              echo "源码包详细信息："
              stat source-package-${VERSION}.zip
              
              # 输出完整环境信息，帮助调试
              echo "=== 完整环境变量 ==="
              env | sort
              
              # 创建发布记录文件，用于验证构建过程
              echo "构建信息记录" > build-info.txt
              echo "构建时间: $(date)" >> build-info.txt
              echo "构建ID: ${CNB_BUILD_ID:-未知}" >> build-info.txt
              echo "版本: ${VERSION}" >> build-info.txt
              echo "源码包大小: $(du -h source-package-${VERSION}.zip | cut -f1)" >> build-info.txt
              cat build-info.txt
              
              # 尝试使用CNB的内置命令发布release，添加详细日志
              echo "开始发布Release..."
              echo "使用CNB命令发布..."
              
              # 兼容不同的CNB版本，尝试两种发布方式
              if command -v cnb > /dev/null; then
                echo "使用cnb命令..."
                # 先显示命令，再执行
                echo "执行: cnb release create --tag \"${VERSION}\" --name \"Release ${VERSION}\" --description \"包含完整Git LFS文件的源码包，自动构建于 $(date +'%Y-%m-%d %H:%M:%S')\" --asset \"source-package-${VERSION}.zip\""
                # 执行命令并保存输出
                cnb release create \
                  --tag "${VERSION}" \
                  --name "Release ${VERSION}" \
                  --description "包含完整Git LFS文件的源码包，自动构建于 $(date +'%Y-%m-%d %H:%M:%S')" \
                  --asset "source-package-${VERSION}.zip" 2>&1 | tee release-output.txt
                RELEASE_EXIT_CODE=$?
                echo "发布命令退出码: ${RELEASE_EXIT_CODE}"
              else
                # 尝试另一种可能的命令格式
                echo "使用HTTP API发布..."
                echo "CNB_API_URL: ${CNB_API_URL:-未设置}"
                # 构建JSON数据但不直接输出完整token
                JSON_DATA="{\"tag_name\":\"${VERSION}\",\"name\":\"Release ${VERSION}\",\"body\":\"包含完整Git LFS文件的源码包，自动构建于 $(date +'%Y-%m-%d %H:%M:%S')\",\"assets\":[\"source-package-${VERSION}.zip\"]}"
                echo "JSON数据: ${JSON_DATA}"
                
                # 执行curl命令
                curl -v -X POST \
                  -H "Content-Type: application/json" \
                  -H "Authorization: Bearer ${CNB_TOKEN:-$TOKEN:-未设置}" \
                  -d "${JSON_DATA}" \
                  ${CNB_API_URL:-https://api.cnb.cool}/api/releases 2>&1 | tee release-output.txt
                RELEASE_EXIT_CODE=$?
                echo "发布命令退出码: ${RELEASE_EXIT_CODE}"
              fi
              
              # 保存所有重要文件到构建产物目录，确保可追踪性
              mkdir -p ./artifacts
              cp "source-package-${VERSION}.zip" ./artifacts/
              cp build-info.txt ./artifacts/
              if [ -f release-output.txt ]; then
                cp release-output.txt ./artifacts/
              fi
              echo "所有构建产物已保存到 ./artifacts/ 目录"
              ls -la ./artifacts/
              
            else
              echo "错误：源码包不存在或为空！"
              ls -lh source-package-*.zip 2>/dev/null || echo "没有找到源码包文件"
              # 创建错误日志文件
              echo "错误详情: 源码包创建失败" > build-error.txt
              echo "时间: $(date)" >> build-error.txt
              echo "版本: ${VERSION}" >> build-error.txt
              cat build-error.txt
            fi
          # 添加详细的错误处理和日志
          on_error: |
            echo "=== 发布阶段失败 - 详细错误分析 ==="
            echo "失败时间: $(date)"
            
            # 显示完整的目录结构和文件信息
            echo "=== 当前目录内容 ==="
            ls -la
            
            # 显示详细的Git状态
            echo "=== Git详细状态 ==="
            git status -v
            git tag -l
            git remote -v
            
            # 检查源码包文件
            echo "=== 源码包检查 ==="
            if [ -f "source-package-*.zip" ]; then
              echo "已创建的源码包："
              ls -lh source-package-*.zip
              du -h source-package-*.zip
              # 检查包的基本信息
              unzip -l source-package-*.zip | head -n 20
            else
              echo "未找到源码包文件"
              find . -name "*.zip" 2>/dev/null || echo "没有找到任何ZIP文件"
            fi
            
            # 显示CNB特定的错误信息和环境
            echo "=== CNB构建环境错误详情 ==="
            echo "构建ID: ${CNB_BUILD_ID:-未知}"
            echo "构建URL: ${CNB_BUILD_URL:-未知}"
            echo "构建状态: ${CNB_BUILD_STATUS:-未知}"
            
            # 创建错误报告文件
            mkdir -p ./error-reports
            ERROR_REPORT="./error-reports/error-$(date +'%Y%m%d-%H%M%S').txt"
            echo "CNB构建错误报告" > "${ERROR_REPORT}"
            echo "时间: $(date)" >> "${ERROR_REPORT}"
            echo "构建ID: ${CNB_BUILD_ID:-未知}" >> "${ERROR_REPORT}"
            echo "" >> "${ERROR_REPORT}"
            echo "目录内容:" >> "${ERROR_REPORT}"
            ls -la >> "${ERROR_REPORT}"
            echo "" >> "${ERROR_REPORT}"
            echo "Git状态:" >> "${ERROR_REPORT}"
            git status >> "${ERROR_REPORT}"
            
            echo "错误报告已保存到: ${ERROR_REPORT}"
            echo "=== 错误分析结束 ==="